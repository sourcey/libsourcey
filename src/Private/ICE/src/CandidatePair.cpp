//
// LibSourcey
// Copyright (C) 2005, Sourcey <http://sourcey.com>
//
// LibSourcey is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 2.1 of the License, or (at your option) any later version.
//
// LibSourcey is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.
//


#include "Sourcey/ICE/CandidatePair.h"
#include "Sourcey/ICE/Agent.h"
#include "Sourcey/ICE/MediaStream.h"
#include "Sourcey/ICE/CheckList.h"
#include "Sourcey/ICE/Component.h"
#include "Sourcey/STUN/Transaction.h"
#include <iostream>


using namespace std;


namespace Sourcey {
namespace ICE {


/*
CandidatePair::CandidatePair() : 
	_queue(NULL), _local(NULL), _remote(NULL), 
	_transaction(NULL), _cancelledTransaction(NULL), 
	_state(CandidatePair::Frozen) 
{
}
*/


CandidatePair::CandidatePair(CheckList& queue, LocalCandidate* local, RemoteCandidate* remote) : 
	_queue(queue), _local(local), _remote(remote), 
	_transaction(NULL), _cancelledTransaction(NULL), 
	_state(CandidatePair::Frozen) 
{
	//assert(_queue);
	assert(_local);
	assert(_remote);
	assert(_local->valid());
	assert(_remote->valid());	
	setLocalCandidate(_local);
}


/*
CandidatePair::CandidatePair(const CandidatePair& r) 
{	
	_queue = r._queue;
	_local = r._local;
	_remote = r._remote;
	_state = r._state;
	_transaction = r._transaction;
	Flaggable::setFlags(r.flags());
}


CandidatePair& CandidatePair::operator = (const CandidatePair& r) 
{
	_local = r._local;
	_remote = r._remote;
	_state = r.state();
	_transaction = r._transaction;
	Flaggable::setFlags(r.flags());
	return *this;
}
*/


CandidatePair::~CandidatePair() 
{
	//Log("debug", this) << "Destroying" << endl;

	clearAllTransactions();
	if (hasFlag(OwnsChildCandidates)) {
		_local->terminate(); _local = NULL;
		delete _remote; _remote = NULL;
	}
	setLocalCandidate(NULL);

	Log("debug", this) << "Destroying: OK" << endl;
}


bool CandidatePair::valid() 
{
	return _local &&
		   _local->valid() && 
		   _remote && 
		   _remote->valid();
}


int CandidatePair::send(const char* data, int size) 
{
	assert(_local);	
	assert(_remote);	
	return _local->send(data, size, _remote->transportAddr());
}


int CandidatePair::send(const IPacket& packet) 
{
	assert(_local);	
	assert(_remote);	
	
	// bind with highest priority..
	// signals can only be bound once...

	return _local->send(packet, _remote->transportAddr());
}


bool CandidatePair::sendConnectivityCheck() 
{
	Log("debug", this) << "Send Connectivity Check Request" << endl;
			
	assert(_local);	
	//assert(_local->component());	
	assert(_remote);	
	assert(!_transaction);

	// 7.1.2.  Sending the Request
	// 
	// The check is generated by sending a Binding request from a local
	// candidate to a remote candidate.  [RFC5389] describes how Binding
	// requests are constructed and generated.  A connectivity check MUST
	// utilize the STUN short-term credential mechanism.  Support for
	// backwards compatibility with RFC 3489 MUST NOT be used or assumed
	// with connectivity checks.  The FINGERPRINT mechanism MUST be used for
	// connectivity checks.
	// 
	// ICE extends STUN by defining several new attributes, including
	// PRIORITY, USE-CANDIDATE, ICE-CONTROLLED, and ICE-CONTROLLING.  These
	// new attributes are formally defined in Section 19.1, and their usage
	// is described in the subsections below.  These STUN extensions are
	// applicable only to connectivity checks used for ICE.
	// 	
	//
	_transaction = new STUN::Transaction(NULL, _local->transportAddr(), _remote->transportAddr(), 
		_queue.stream().agent().options().maxRequestRetries, 
		_queue.stream().agent().options().transactionTimeout);
	_transaction->StateChange += delegate(this, &CandidatePair::onTransactionStateChange);
	_transaction->request().setType(STUN::Message::Binding);

	// 7.1.2.1.  PRIORITY and USE-CANDIDATE
	// 
	// An agent MUST include the PRIORITY attribute in its Binding request.
	// The attribute MUST be set equal to the priority that would be
	// assigned, based on the algorithm in Section 4.1.2, to a peer
	// reflexive candidate, should one be learned as a consequence of this
	// check (see Section 7.1.3.2.1 for how peer reflexive candidates are
	// learned).  This priority value will be computed identically to how
	// the priority for the local candidate of the pair was computed, except
	// that the type preference is set to the value for peer reflexive
	// candidate types.
	// 
	// The controlling agent MAY include the USE-CANDIDATE attribute in the
	// Binding request.  The controlled agent MUST NOT include it in its
	// Binding request.  This attribute signals that the controlling agent
	// wishes to cease checks for this component, and use the candidate pair
	// resulting from the check for this component.  Section 8.1.1 provides
	// guidance on determining when to include it.

	// PRIORITY
	STUN::ICEPriority* priorityAttr = new STUN::ICEPriority();
	priorityAttr->setValue(LocalCandidate::computePriority(Candidate::PeerReflexive, _local->componentID()));
	_transaction->request().add(priorityAttr);

	// USE-CANDIDATE
	if (_queue.stream().agent().role() == Agent::Controlling)
		_transaction->request().add(new STUN::ICEUseCandidate);

	// 7.1.2.2.  ICE-CONTROLLED and ICE-CONTROLLING
	// 
	// The agent MUST include the ICE-CONTROLLED attribute in the request if
	// it is in the controlled role, and MUST include the ICE-CONTROLLING
	// attribute in the request if it is in the controlling role.  The
	// content of either attribute MUST be the tie-breaker that was
	// determined in Section 5.2.  These attributes are defined fully in
	// Section 19.1.
	//	
	if (_queue.stream().agent().role() == Agent::Controlling) {		
		STUN::ICEControlling* controlAttr = new STUN::ICEControlling();
		controlAttr->setValue(_queue.stream().agent().tieBreaker());
		_transaction->request().add(controlAttr);
	} 
	else {
		STUN::ICEControlling* controlAttr = new STUN::ICEControlling();
		controlAttr->setValue(_queue.stream().agent().tieBreaker());
		_transaction->request().add(controlAttr);
	}

	// 7.1.2.3.  Forming Credentials
	// 
	// A Binding request serving as a connectivity check MUST utilize the
	// STUN short-term credential mechanism.  The username for the
	// credential is formed by concatenating the username fragment provided
	// by the peer with the username fragment of the agent sending the
	// request, separated by a colon (":").  The password is equal to the
	// password provided by the peer.  For example, consider the case where
	// agent L is the offerer, and agent R is the answerer.  Agent L
	// included a username fragment of LFRAG for its candidates and a
	// password of LPASS.  Agent R provided a username fragment of RFRAG and
	// a password of RPASS.  A connectivity check from L to R utilizes the
	// username RFRAG:LFRAG and a password of RPASS.  A connectivity check
	// from R to L utilizes the username LFRAG:RFRAG and a password of
	// LPASS.  The responses utilize the same usernames and passwords as the
	// requests (note that the USERNAME attribute is not present in the
	// response).
	// 
	// 7.1.2.4.  DiffServ Treatment
	// 
	// If the agent is using Diffserv Codepoint markings [RFC2475] in its
	// media packets, it SHOULD apply those same markings to its
	// connectivity checks.

	// USERNAME
	assert(!_queue.stream().remoteUFrag().empty());
	assert(!_queue.stream().agent().options().localUFrag.empty());
	string username(_queue.stream().remoteUFrag() + ":" + _queue.stream().agent().options().localUFrag);
	STUN::Username* usernameAttr = new STUN::Username;
	usernameAttr->copyBytes(username.c_str(), username.size());
	_transaction->request().add(usernameAttr);		

	// MESSAGE-INTEGRITY
	assert(!_queue.stream().remotePassword().empty());
	STUN::MessageIntegrity* integrityAttr = new STUN::MessageIntegrity;	
	integrityAttr->setKey(_queue.stream().agent().options().localPassword);	 //_queue.stream().remotePassword()
	_transaction->request().add(integrityAttr);
	
	_transaction->send(); // start the timer
	return send(_transaction->request()) > 0;
}


bool CandidatePair::sendConnectivityCheckResponse(const STUN::Message& request, 
												  //const Net::Address& localAddress, 
												  const Net::Address& peerAddress) 
{
	Log("debug", this) << "Send Connectivity Check Response" << endl;

	STUN::Message response;
	response.setType(STUN::Message::Binding);
	response.setTransactionID(request.transactionID());	

	// USERNAME
	string username(_queue.stream().remoteUFrag() + ":" + _queue.stream().agent().options().localUFrag);
	STUN::Username* usernameAttr = new STUN::Username;
	usernameAttr->copyBytes(username.c_str(), username.size());
	response.add(usernameAttr);			

	// XOR-MAPPED-ADDRESS
	STUN::XorMappedAddress* addressAttr = new STUN::XorMappedAddress;
	addressAttr->setFamily(1);
	addressAttr->setPort(peerAddress.port());
	addressAttr->setIP(peerAddress.host().toString());
	response.add(addressAttr);	

	// MESSAGE-INTEGRITY
	// Any response generated by a server MUST include the MESSAGE-INTEGRITY 
	// attribute, computed using the password utilized to authenticate the 
	// request. The response MUST NOT contain the USERNAME attribute.
	STUN::MessageIntegrity* integrityAttr = new STUN::MessageIntegrity;
	integrityAttr->setKey(_queue.stream().agent().options().localPassword);
	response.add(integrityAttr);

	return send(response) > 0;
}


void CandidatePair::cancelConnectivityCheck() 
{
	Log("debug", this) << "Canceling Current Transaction" << endl;

	// Cancellation means that the agent will not retransmit the request, 
	// will not treat the lack of response to be a failure, but will wait 
	// the duration of the transaction timeout for a response. 
	assert(_transaction);
	_cancelledTransaction = _transaction;
	_cancelledTransaction->StateChange += delegate(this, &CandidatePair::onTransactionStateChange);
	_cancelledTransaction->cancel();
	_transaction = NULL;
}


void CandidatePair::clearTransaction(STUN::Transaction* transaction)
{
	if (_transaction == transaction) {
		_transaction->StateChange -= delegate(this, &CandidatePair::onTransactionStateChange);
		//delete _transaction;
		_transaction = NULL;
	} 
	else if (_cancelledTransaction == transaction) {
		_cancelledTransaction->StateChange -= delegate(this, &CandidatePair::onTransactionStateChange);
		//delete _cancelledTransaction;
		_cancelledTransaction = NULL;
	}
}


void CandidatePair::clearAllTransactions()
{
	if (_transaction)
		clearTransaction(_transaction);
	if (_cancelledTransaction)
		clearTransaction(_cancelledTransaction);
}


void CandidatePair::onReceiveSTUNMessage(void* sender, const STUN::Message& message, const Net::Address& peerAddress)
{
	Log("debug", this) << "Received: " << message.toString() << endl;

	// FIXME: While debugging ensure the PacketInfo data matches
	// the provided peerAddress. This check can be removed.
	Net::PacketInfo* info = reinterpret_cast<Net::PacketInfo*>(message.info);
	assert(info);
	assert(info->localAddress ==  _local->transportAddr());
	assert(info->peerAddress == _remote->transportAddr());
	assert(info->peerAddress == peerAddress);

	if ((_transaction && 
		 _transaction->process(message)) || //, _local->transportAddr(), peerAddress
		(_cancelledTransaction && 
		 _cancelledTransaction->process(message))) { //, _local->transportAddr(), peerAddress
		// The STUN message is our Connectivity Check Response, and has been handled...
		
		throw StopPropagation();
	}

	// The STUN message was not our Connectivity Check Response, continue processing...
}


void CandidatePair::onTransactionStateChange(void* sender, TransactionState& state, const TransactionState&) 
{
	Log("debug", this) << "Transaction State Changed: " << state.toString() << endl;
	
	STUN::Transaction* transaction = reinterpret_cast<STUN::Transaction*>(sender);
	switch (transaction->state().id()) {	
	case TransactionState::Success:
		assert(transaction->response().type() == STUN::Message::Binding);
		if (transaction->response().type() != STUN::Message::Binding)
			break;
		if (transaction->response().state() == STUN::Message::SuccessResponse) {
			Log("debug", this) << "Received BINDING-RESPONSE Success from " << transaction->peerAddress().toString() << endl;
			_queue.onConnectivityCheckSuccess(this, transaction->response());
			clearTransaction(transaction);
		} else if (transaction->response().state() == STUN::Message::ErrorResponse) {
			Log("debug", this) << "Received BINDING-RESPONSE Error from " << transaction->peerAddress().toString() << endl;
			_queue.onConnectivityCheckFailed(this, transaction->response());
			clearTransaction(transaction);
		}
		break;		

	case TransactionState::Cancelled:

		// If the transaction matches our cancelled transaction 
		// just disregard it.
		// @see [rfc5245] 7.2.1.4. Triggered Checks
		assert(transaction->cancelled());
		assert(transaction == _cancelledTransaction);
		if (transaction == _cancelledTransaction// ||
			//transaction->cancelled
			) {
			clearTransaction(transaction);
		}
		break;

	case TransactionState::Failed:
		Log("debug", this) << "Current Connectivity Check Failed: " << transaction->request().toString() << endl;
		clearTransaction(transaction);
		setState(CandidatePair::Failed);

		/*
		
		Log("debug", this) << "Max Retry Count Reached" << endl;
		// TODO: Immediate failure on unrecoverable error.
		if (transaction->attempts < _queue.stream().agent().options().maxRequestRetries) {
			Log("debug", this) << "Re-sending Connectivity Check" << endl;
			transaction->send(); // start the timer
			send(transaction->request);
		} else {
		}
		*/
		break;
	}
}


void CandidatePair::setLocalCandidate(LocalCandidate* local)
{ 
	if (_local) {
		_local->StateChange -= delegate(this, &CandidatePair::onCandidateStateChange);	
		_local->STUNMessageReceived -= delegate(this, &CandidatePair::onReceiveSTUNMessage); 
	}

	_local = local; 

	if (_local) {
		_local->StateChange += delegate(this, &CandidatePair::onCandidateStateChange);	
		_local->STUNMessageReceived += delegate(this, &CandidatePair::onReceiveSTUNMessage, 0); 
	}
}


void CandidatePair::setRemoteCandidate(RemoteCandidate* remote)
{ 
	_remote = remote; 
};


void CandidatePair::onCandidateStateChange(void* sender, CandidateState& state, const CandidateState&)
{
	Log("debug", this) << "Local Candidate State Changed: " << state.toString() << endl;
	LocalCandidate* candidate = reinterpret_cast<LocalCandidate*>(sender);

	switch (state.id()) {	

	// If our local candidate gets terminated for some reason 
	// we need to destroy the candidate pair straight away.
	case CandidateState::Terminating:
		//_local->StateChange -= delegate(this, &CandidatePair::onCandidateStateChange);	
		//_local->STUNMessageReceived -= delegate(this, &CandidatePair::onReceiveSTUNMessage); 
		//_local = NULL;
		setLocalCandidate(NULL);
		_queue.removeCandidatePair(this);
		delete this;
		break;
	}
}


void CandidatePair::setFlag(UInt32 flag) 
{ 
	Log("debug", this) << "Setting FLAG: " << flagToString(flag) << endl;	
	assert(!hasFlag(flag));
	Flaggable::setFlag(flag);
}


void CandidatePair::setState(const State& state) 
{ 
	Log("debug", this) << "State changed from " << stateToString(_state) << " to " <<  stateToString(state) << endl;	
	assert(_state != CandidatePair::Succeeded);
	assert(_state != state);
	_state = state;
	
	switch (state) {
	case CandidatePair::Waiting:
		break;
	case CandidatePair::InProgress:
		break;
	case CandidatePair::Succeeded:
		clearAllTransactions();
		break;
	case CandidatePair::Failed:
		break;
	case CandidatePair::Frozen:
		break;
	}

	/*
	if (_state == CandidatePair::Succeeded)
	{
		//_local->STUNMessageReceived -= delegate(this, &CandidatePair::onReceiveSTUNMessage);
	}
	*/
}


string CandidatePair::stateToString(UInt32 state) 
{
	switch (state) {
	case CandidatePair::Waiting:
		return "Waiting";
	case CandidatePair::InProgress:
		return "In-Progress";
	case CandidatePair::Succeeded:
		return "Succeeded";
	case CandidatePair::Failed:
		return "Failed";
	case CandidatePair::Frozen:
		return "Frozen";
	}
	assert(false);
	return "Unknown";
}


string CandidatePair::flagToString(UInt32 flag) 
{
	switch (flag) {
	case CandidatePair::Default:
		return "Default";
	case CandidatePair::Valid:
		return "Valid";
	case CandidatePair::Nominated:
		return "Nominated";
	case CandidatePair::Selected:
		return "Selected";
	case CandidatePair::NominateOnSuccess:
		return "NominateOnSuccess";
	//case CandidatePair::DeleteOnResponse:
	//	return "DeleteOnResponse";
	//case CandidatePair::CurrentRequestCancalled:
	//	return "CurrentRequestCancalled";
	case CandidatePair::UpdateLoosingOnResponse:
		return "UpdateLoosingOnResponse";
	case CandidatePair::OwnsChildCandidates:
		return "OwnsChildCandidates";
	}
	//assert(false);
	return "Unknown";
}


string CandidatePair::stateString() const 
{
	return stateToString(_state);
}


string CandidatePair::flagsString() const 
{
    stringstream ost;
	if (hasFlag(CandidatePair::Default))
		ost << "Default:";
	if (hasFlag(CandidatePair::Valid))
		ost << "Valid:";
	if (hasFlag(CandidatePair::Nominated))
		ost << "Nominated:";
	if (hasFlag(CandidatePair::Selected))
		ost << "Selected:";
	if (hasFlag(CandidatePair::NominateOnSuccess))
		ost << "NominateOnSuccess:";
	//if (hasFlag(CandidatePair::DeleteOnResponse))
	//	ost << "DeleteOnResponse:";
	if (hasFlag(CandidatePair::UpdateLoosingOnResponse))
		ost << "UpdateLoosingOnResponse:";
	if (hasFlag(CandidatePair::OwnsChildCandidates))
		ost << "OwnsChildCandidates:";
	return ost.str();
}




void CandidatePair::printLog(std::ostream& ost) const 
{	
	ost << "["
		<< className()
		<< ":"
		<< this
		<< ":"
		<< stateString()
		<< "] ";

	//ss << _local->component().printLog(std::ostream& ost);
	//ss << "CandidatePair[" << stateString() << ":" << flagsString() << "]";
}


string CandidatePair::toString() const 
{
    stringstream ost;
	ost << "CandidatePair["
		<< "\n\tState(" << stateString() << "):" << "Flags(" << flagsString() << ")"
		<< "\n\tL(" << (const char*)(_local ? _local->toString().c_str() : "null") << ")"
		<< "\n\tR(" << (const char*)(_remote ? _remote->toString().c_str() : "null") << "):"
		<< "]";
	return ost.str();
}


bool CandidatePair::operator == (const CandidatePair& r) const 
{
  return (_local == r._local) && (_remote == r._remote);
}


bool CandidatePair::operator != (const CandidatePair& r) const 
{
  return (_local != r._local) && (_remote != r._remote);
}



} // namespace Sourcey
} // namespace ICE 